"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const misc_1 = require("./misc");
const database_1 = require("./database");
const record_1 = require("./record");
const SCHEMA_CONFIG = { models: [] };
const MODEL_CONFIG = { fields: [] };
const FIELD_CONFIG = {};
class Schema {
    constructor(database, config = SCHEMA_CONFIG) {
        this.models = [];
        this.modelMap = {};
        this.database = database;
        this.config = Object.assign({}, SCHEMA_CONFIG, config);
        for (const table of database.tables) {
            if (!table.shortName) {
                table.shortName = config.tablePrefix
                    ? table.name.replace(config.tablePrefix, '')
                    : table.name;
            }
            const model = new Model(this, table, this.getModelConfig(table));
            this.addModel(model);
        }
        for (const model of this.models) {
            model.resolveForeignKeyFields();
        }
        for (const model of this.models) {
            model.resolveRelatedFields();
        }
    }
    getModelConfig(table) {
        return this.config.models.find(config => config.table === table.shortName);
    }
    addModel(model) {
        if (model.name in this.modelMap) {
            throw Error(`Duplicate model name: ${model.name}`);
        }
        if (model.table.name !== model.name) {
            if (model.table.name in this.modelMap) {
                throw Error(`Duplicate model name: ${model.table.name})`);
            }
        }
        this.models.push(model);
        this.modelMap[model.name] = model;
        if (model.name !== model.table.name) {
            this.modelMap[model.table.name] = model;
        }
    }
    model(name) {
        return this.modelMap[name];
    }
}
exports.Schema = Schema;
class Model {
    constructor(domain, table, config) {
        this.fields = [];
        this.uniqueKeys = [];
        this.fieldMap = {};
        this.domain = domain;
        this.table = table;
        this.config = Object.assign({}, MODEL_CONFIG, config);
        this.name = this.config.name || misc_1.toPascalCase(table.shortName);
        this.pluralName =
            this.config.pluralName || misc_1.toCamelCase(misc_1.pluralise(table.shortName));
        const references = {};
        for (const index of table.constraints) {
            if (index.references) {
                if (index.columns.length > 1) {
                    throw Error('Composite foreign keys are not supported');
                }
                references[index.columns[0]] = index;
            }
        }
        for (const column of table.columns) {
            const config = this.getFieldConfig(column);
            const field = references[column.name]
                ? new ForeignKeyField(this, column, config)
                : new SimpleField(this, column, config);
            this.addField(field);
        }
    }
    getFieldConfig(column) {
        return this.config.fields.find(field => field.column === column.name);
    }
    field(name) {
        return this.fieldMap[name];
    }
    keyField() {
        return this.primaryKey && this.primaryKey.fields.length === 1
            ? this.primaryKey.fields[0]
            : null;
    }
    keyValue(row) {
        return this.valueOf(row, this.keyField().name);
    }
    valueOf(row, name) {
        if (!row)
            return undefined;
        const field = typeof name === 'string' ? this.field(name) : name;
        let value = row[field.name];
        if (field instanceof ForeignKeyField) {
            let key = field;
            while (value !== undefined && !database_1.isValue(value)) {
                key = key.referencedField;
                value = value[key.name];
            }
        }
        return value;
    }
    checkUniqueKey(row, reject) {
        if (!row)
            return null;
        reject = reject || database_1.isEmpty;
        let uniqueKey = this.primaryKey;
        for (const field of uniqueKey.fields) {
            let value = row[field.name];
            if (value === undefined) {
                value = row[field.name + '__in'];
            }
            if (reject(value)) {
                uniqueKey = null;
                break;
            }
        }
        if (!uniqueKey) {
            for (const key of this.uniqueKeys) {
                if (!key.primary) {
                    let missing;
                    for (const field of key.fields) {
                        if (reject(row[field.name])) {
                            missing = field;
                            break;
                        }
                    }
                    if (!missing) {
                        uniqueKey = key;
                        break;
                    }
                }
            }
        }
        if (!uniqueKey) {
            for (const name in row) {
                const field = this.field(name);
                if (field instanceof RelatedField) {
                    const model = field.referencingField.model;
                    if (model.checkUniqueKey(row[name])) {
                        return row[name];
                    }
                }
            }
        }
        return uniqueKey;
    }
    getUniqueFields(row) {
        const uniqueKey = this.checkUniqueKey(row);
        if (uniqueKey) {
            const fields = {};
            for (const field of uniqueKey.fields) {
                const value = row[field.name];
                if (value instanceof record_1.Record) {
                    fields[field.name] = value.__primaryKey();
                }
                else {
                    fields[field.name] = row[field.name];
                }
            }
            return fields;
        }
    }
    // Get the number of foreign key fields pointing to the given model
    getForeignKeyCount(model) {
        let count = 0;
        for (const field of this.fields) {
            if (field instanceof ForeignKeyField) {
                if (field.referencedField.model === model) {
                    count++;
                }
            }
        }
        return count;
    }
    getOtherForeignKeyField(field) {
        const model = field.referencedField.model;
        for (const item of this.fields) {
            if (item instanceof ForeignKeyField) {
                if (item.referencedField.model === model) {
                    if (item !== field) {
                        return item;
                    }
                }
            }
        }
    }
    getForeignKeyOf(model) {
        for (const field of this.fields) {
            if (field instanceof ForeignKeyField) {
                if (field.referencedField.model === model) {
                    return field;
                }
            }
        }
        return null;
    }
    resolveForeignKeyFields() {
        for (const index of this.table.constraints) {
            if (index.primaryKey || index.unique) {
                const fields = index.columns.map(name => this.field(name));
                const uniqueKey = new UniqueKey(fields, index.primaryKey);
                for (const field of fields) {
                    field.uniqueKey = uniqueKey;
                }
                this.uniqueKeys.push(uniqueKey);
                if (index.primaryKey) {
                    this.primaryKey = uniqueKey;
                }
            }
            if (index.references) {
                const field = this.field(index.columns[0]);
                if (field instanceof ForeignKeyField) {
                    const referencedTable = this.domain.model(index.references.table);
                    const columnName = index.references.columns[0];
                    const referencedField = referencedTable.field(columnName);
                    if (referencedField instanceof SimpleField) {
                        field.referencedField = referencedField;
                    }
                    else {
                        throw Error(`Bad referenced field: ${columnName}`);
                    }
                }
            }
        }
    }
    isClosureField(field) {
        const closureTable = field.referencedField.model.config.closureTable;
        if (closureTable && closureTable.name === field.model.table.name) {
            const fields = Object.assign({ ancestor: 'ancestor', descendant: 'descendant' }, closureTable.fields);
            return field.name === fields.ancestor || field.name === fields.descendant;
        }
        return false;
    }
    resolveRelatedFields() {
        const fieldCount = this.fields.length;
        for (let i = 0; i < fieldCount; i++) {
            const field = this.fields[i];
            if (field instanceof ForeignKeyField && !this.isClosureField(field)) {
                const relatedField = new RelatedField(field);
                relatedField.model.addField(relatedField);
                field.relatedField = relatedField;
            }
        }
    }
    addField(field) {
        if (field.name in this.fieldMap) {
            throw Error(`Duplicate field name: ${field.displayName()}`);
        }
        let column;
        if (field instanceof SimpleField) {
            column = field.column;
            if (column.name in this.fieldMap) {
                throw Error(`Duplicate field name: ${column.name}`);
            }
        }
        this.fields.push(field);
        this.fieldMap[field.name] = field;
        if (column && column.name !== field.name) {
            this.fieldMap[column.name] = field;
        }
    }
}
exports.Model = Model;
class Field {
    constructor(name, model, config) {
        this.name = name;
        this.model = model;
        this.config = config;
    }
    isUnique() {
        return this.uniqueKey && this.uniqueKey.fields.length == 1;
    }
    displayName() {
        return `${this.model.name}::${this.name}`;
    }
}
exports.Field = Field;
class SimpleField extends Field {
    constructor(model, column, config) {
        config = Object.assign({}, FIELD_CONFIG, config);
        super(config.name || misc_1.toCamelCase(column.name), model, config);
        this.column = column;
    }
}
exports.SimpleField = SimpleField;
class ForeignKeyField extends SimpleField {
    constructor(model, column, config) {
        super(model, column, config);
        if (!this.config.name) {
            const match = /(.+?)(?:_id|Id)/.exec(column.name);
            if (match) {
                this.name = misc_1.toCamelCase(match[1]);
            }
        }
    }
}
exports.ForeignKeyField = ForeignKeyField;
class RelatedField extends Field {
    constructor(field) {
        const model = field.referencedField.model;
        const config = field.config;
        super(config.relatedName, model, config);
        this.referencingField = field;
        let throughFieldName = config.throughField;
        if (throughFieldName === undefined && !config.relatedName) {
            const model = this.referencingField.model;
            if (model.fields.length <= 3) {
                let other, extra;
                for (const uniqueKey of model.uniqueKeys) {
                    if (uniqueKey.fields.length === 2) {
                        for (const field of model.fields) {
                            if (this.referencingField === field)
                                continue;
                            if (field instanceof ForeignKeyField) {
                                other = field;
                            }
                            else if (!field.uniqueKey.primary) {
                                extra = field;
                                break;
                            }
                        }
                    }
                }
                if (!extra && other) {
                    throughFieldName = other.name;
                }
            }
        }
        if (throughFieldName) {
            const throughField = field.model.field(throughFieldName);
            if (throughField instanceof ForeignKeyField) {
                this.throughField = throughField;
            }
            else {
                throw Error(`Field ${throughFieldName} is not a foreign key`);
            }
        }
        if (!this.name) {
            if (this.throughField) {
                if (field.model.getForeignKeyCount(this.model) === 1) {
                    this.name = this.throughField.referencedField.model.pluralName;
                }
                else {
                    this.name =
                        field.model.getOtherForeignKeyField(field).name +
                            misc_1.toPascalCase(this.throughField.referencedField.model.pluralName);
                }
            }
            else if (field.isUnique()) {
                this.name = lcfirst(field.model.name);
            }
            else {
                if (field.model.getForeignKeyCount(this.model) === 1) {
                    this.name = field.model.pluralName;
                }
                else {
                    this.name = field.model.pluralName + misc_1.toPascalCase(field.name);
                }
            }
        }
    }
    // Example: UserOrder, CategoryCategoryAncestor
    getPascalName(plural) {
        const model = this.referencingField.model;
        if (this.throughField) {
            if (model.getForeignKeyCount(this.model) === 1) {
                const model = this.throughField.referencedField.model;
                return `${this.model.name}${misc_1.pluralise(model.name)}`;
            }
            else {
                return misc_1.toPascalCase(this.throughField.relatedField.name);
            }
        }
        if (model.getForeignKeyCount(this.model) === 1) {
            return `${this.model.name}${plural ? misc_1.pluralise(model.name) : model.name}`;
        }
        const name = this.referencingField.name;
        const suffix = misc_1.toPascalCase(plural ? misc_1.pluralise(name) : name);
        return `${this.model.name}${model.name}${suffix}`;
    }
}
exports.RelatedField = RelatedField;
class UniqueKey {
    constructor(fields, primary = false) {
        this.fields = fields;
        this.primary = primary;
    }
    name() {
        return this.fields.map(field => field.name).join('-');
    }
    autoIncrement() {
        return this.fields.length === 1 && this.fields[0].column.autoIncrement;
    }
}
exports.UniqueKey = UniqueKey;
function lcfirst(s) {
    return s.charAt(0).toLowerCase() + s.slice(1);
}
exports.lcfirst = lcfirst;
function getReferencingFields(model) {
    const fields = [];
    for (const entry of model.domain.models) {
        for (const field of entry.fields) {
            if (field instanceof ForeignKeyField) {
                if (field.referencedField.model === model) {
                    fields.push(field);
                }
            }
        }
    }
    return fields;
}
exports.getReferencingFields = getReferencingFields;
function setModelName(config, model, name) {
    const re = new RegExp(`(\\b|[^A-Za-z0-9])${model.table.shortName}(\\b|[^A-Za-z0-9])`);
    for (const field of getReferencingFields(model)) {
        if (re.test(field.column.name)) {
            const modelConfig = getModelConfig(config, field.model);
            if (re.test(field.column.name)) {
                const s = field.column.name.replace(re, `$1${name}$2`);
                // cf. ForeignKeyField::constructor
                setFieldName(modelConfig, field, lcfirst(misc_1.toCamelCase(s.replace(/_id$/, ''))));
            }
        }
    }
    const modelConfig = getModelConfig(config, model);
    modelConfig.name = name;
    modelConfig.pluralName = lcfirst(misc_1.pluralise(name));
}
exports.setModelName = setModelName;
function getModelConfig(config, model) {
    config.models = config.models || [];
    let entry = config.models.find(config => config.table === model.table.shortName);
    if (!entry) {
        entry = {
            table: model.table.shortName
        };
        config.models.push(entry);
    }
    return entry;
}
function setFieldName(config, field, name) {
    if (!config.fields) {
        config.fields = [
            {
                column: field.column.name,
                name
            }
        ];
    }
    else {
        const entry = config.fields.find(entry => entry.column === field.column.name);
        if (!entry) {
            config.fields.push({
                column: field.column.name,
                name
            });
        }
        else {
            entry.name = name;
        }
    }
}
//# sourceMappingURL=model.js.map